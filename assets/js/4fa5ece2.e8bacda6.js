"use strict";(self.webpackChunkotter_guides=self.webpackChunkotter_guides||[]).push([[870],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),h=i,f=p["".concat(s,".").concat(h)]||p[h]||d[h]||o;return t?r.createElement(f,a(a({ref:n},u),{},{components:t})):r.createElement(f,a({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=p;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8299:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],l={id:"oop-exercise",title:"Object Oriented Programming Exercise"},s=void 0,c={unversionedId:"interview/interviewee/SWE/oop-exercise",id:"interview/interviewee/SWE/oop-exercise",title:"Object Oriented Programming Exercise",description:"This exercise is quite similar to what you would find in an Algorithmic Exercise with the exception that this one will also focus on your skills to model the problem using object-oriented programming, and in most cases, the problem to solve will be a little bit easier than those presented on an Algorithmic Exercise.",source:"@site/docs/interview/interviewee/SWE/oop-exercise.mdx",sourceDirName:"interview/interviewee/SWE",slug:"/interview/interviewee/SWE/oop-exercise",permalink:"/otter-guides/interview/interviewee/SWE/oop-exercise",draft:!1,editUrl:"https://github.com/proyecto-nutria/otter-guides/docs/interview/interviewee/SWE/oop-exercise.mdx",tags:[],version:"current",frontMatter:{id:"oop-exercise",title:"Object Oriented Programming Exercise"},sidebar:"interviewee_swe_exercises",previous:{title:"Algorithmic Exercise",permalink:"/otter-guides/interview/interviewee/SWE/algorithmic-exercise"},next:{title:"System Design Exercise",permalink:"/otter-guides/interview/interviewee/SWE/system-design-exercise"}},u={},d=[{value:"Example Exercise:",id:"example-exercise",level:3},{value:"Statement",id:"statement",level:4},{value:"Solution without using OO concepts",id:"solution-without-using-oo-concepts",level:4},{value:"Solution using the four pillars of OO: Abstraction, Encapsulation, Inheritance, and Polymorphism",id:"solution-using-the-four-pillars-of-oo-abstraction-encapsulation-inheritance-and-polymorphism",level:4},{value:"General Tips to succeed in the Object Oriented Design Exercise",id:"general-tips-to-succeed-in-the-object-oriented-design-exercise",level:3}],p={toc:d};function h(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This exercise is quite similar to what you would find in an ",(0,o.kt)("a",{parentName:"p",href:"algorithmic-exercise"},"Algorithmic Exercise")," with the exception that this one will also focus on your skills to model the problem using object-oriented programming, and in most cases, the problem to solve will be a little bit easier than those presented on an Algorithmic Exercise.\nThe time you will be given for this exercise will be around 30 min to 1 hr."),(0,o.kt)("h3",{id:"example-exercise"},"Example Exercise:"),(0,o.kt)("h4",{id:"statement"},"Statement"),(0,o.kt)("p",null,"Given a binary tree represented with internal nodes and leaf nodes, print the value contained in all the leaf nodes."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A LeafNode is a node that does not have any children and that contains an integer value")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"An InternalNode is a node that can have 1 or 2 children nodes that can either be another InternalNode or a Leaf"))),(0,o.kt)("h4",{id:"solution-without-using-oo-concepts"},"Solution without using OO concepts"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n    Node left;\n    Node right;\n    int value;\n    Node(int value, Node left, Node right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Main {\n    public static void printValuesInBTree(Node node) {           //                 \n        if (node == null) return;                                //        ()\n        if (node.left == null && node.right == null) { // isLeaf //       /  \\\n            System.out.println(node.value);                      //     ()    3  \n        } else {                                                 //    /  \\\n            printValuesInBTree(node.left);                       //   1   ()\n            printValuesInBTree(node.right);                      //      /\n        }                                                        //     2 \n    }                                                            //                \n\n    public static void main(String[] args) {\n        Node root = new Node(0, new Node(0, new Node(1, null, null), new Node(0, new Node(2, null, null), null)), new Node(3, null, null));\n        printValuesInBTree(root);\n    }\n}\n")),(0,o.kt)("h4",{id:"solution-using-the-four-pillars-of-oo-abstraction-encapsulation-inheritance-and-polymorphism"},"Solution using the four pillars of OO: Abstraction, Encapsulation, Inheritance, and Polymorphism"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'abstract class Node {\n    // most languages already have a way to retrieve the type of an object\n    // to be generic we are going to use a method that will tell us the type directly\n    abstract String type();\n}\n\nclass LeafNode extends Node {\n    private int value;\n\n    LeafNode(int value) {\n        this.value = value;\n    }\n    String type() {\n        return "leaf";\n    }\n    int getValue() {\n        return this.value;\n    }\n}\n\nclass InternalNode extends Node {\n    private Node left;\n    private Node right;\n\n    InternalNode(Node left, Node right) {\n        this.left = left;\n        this.right = right;\n    }\n    String type() {\n        return "internal";\n    }\n    Node getLeftNode() {\n        return this.left;\n    }\n    Node getRightNode() {\n        return this.right;\n    }\n}\n\npublic class Main {\n    public static void printValuesInBTree(Node node) {           //\n        if (node == null) return;                                //        ()\n        if (node.type() == "leaf") {                             //       /  \\\n            LeafNode leaf = (LeafNode) node;                     //     ()    3  \n            System.out.println(leaf.getValue());                 //    /  \\\n        } else {                                                 //   1   ()\n            InternalNode internalNode = (InternalNode) node;     //      /\n            printValuesInBTree(internalNode.getLeftNode());      //     2 \n            printValuesInBTree(internalNode.getRightNode());     //                \n        }\n    }\n\n\n    public static void main(String[] args) {\n        Node root = new InternalNode(new InternalNode(new LeafNode(1), new InternalNode(new LeafNode(2), null)), new LeafNode(3));\n        printValuesInBTree(root);\n    }\n}\n')),(0,o.kt)("h3",{id:"general-tips-to-succeed-in-the-object-oriented-design-exercise"},"General Tips to succeed in the Object Oriented Design Exercise"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Follow the flow diagram and tips presented in ",(0,o.kt)("a",{parentName:"li",href:"algorithmic-exercise"},"Algorithmic Exercise")," during the interview"),(0,o.kt)("li",{parentName:"ul"},"Study more ",(0,o.kt)("a",{parentName:"li",href:"https://refactoring.guru/design-patterns"},"Design Patterns"))))}h.isMDXComponent=!0}}]);